---
description: Model Context Protocol (MCP) Server Standards
alwaysApply: false
---

# Model Context Protocol (MCP) Server Standards

> **Enterprise-grade MCP server implementation standards**

## Quick Navigation

- üöÄ [Velocity Hub](mdc:.cursor/rules/00-velocity-hub.mdc) - Start here
- üèóÔ∏è [MCP Servers](mdc:.cursor/rules/21-mcp-servers.mdc) - Implementation patterns
- üîß [Automation Suggestions](mdc:.cursor/rules/04-automation-suggestions.mdc) - Boilerplate generation
- ‚òÅÔ∏è [Workers Deployment](mdc:.cursor/rules/30-workers-deployment.mdc) - Production deployment
- üè¢ [Enterprise Standards](mdc:.cursor/rules/02-enterprise-standards.mdc) - Security & GDPR

## MCP Protocol Overview

All servers implement the [Model Context Protocol](https://modelcontextprotocol.io/) for enabling LLMs to securely
access enterprise data sources, business tools, and AI agents.

## New Server Quickstart Checklist

Creating a new MCP server? Follow this checklist:

- [ ] **Server Initialization**: Create Server instance with name and version
- [ ] **Define Tool Schemas**: Use JSON Schema for input validation
- [ ] **Implement Tool Handlers**: Process validated inputs with CallToolRequestSchema
- [ ] **List Tools Handler**: Respond to ListToolsRequestSchema with tool definitions
- [ ] **Input Validation**: Validate all inputs before processing
- [ ] **Error Handling**: Return structured errors with clear messages
- [ ] **State Management**: Track history and registries for audit trails
- [ ] **Visualization**: Provide human-readable output formatting
- [ ] **Shutdown Handlers**: Implement graceful shutdown on SIGINT/SIGTERM
- [ ] **Tests**: Write tests with 80%+ coverage
- [ ] **Documentation**: Create README following [Documentation](mdc:.cursor/rules/12-documentation.mdc)
- [ ] **Security**: Implement HITL for sensitive operations

**See implementation patterns:** [MCP Servers](mdc:.cursor/rules/21-mcp-servers.mdc)

## Core MCP Server Architecture

### Server Initialization Pattern

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server(
  {
    name: "server-name",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Tool handlers
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // Handle tool calls
});

// Start server
const transport = new StdioServerTransport();
await server.connect(transport);
```

### Tool Discovery and Registration

Every MCP server MUST:

1. **Define Tool Schemas**: Use JSON Schema for input validation
2. **Implement Tool Handlers**: Process validated inputs
3. **Return Structured Results**: Consistent response format
4. **Handle Errors Gracefully**: Clear error messages with context

Example tool handler pattern from [src/memory/src/index.ts](mdc:src/memory/src/index.ts):

```typescript
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  switch (name) {
    case "create_entities":
      // Validate input
      // Process request
      // Return result
      return { content: [{ type: "text", text: result }] };

    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});
```

## Schema Validation

### Input Validation Pattern

All tool inputs MUST be validated before processing:

```typescript
private validateInput(input: unknown): ValidatedType {
  if (typeof input !== "object" || input === null) {
    throw new Error("Invalid input: expected object");
  }

  // Type guards and validation
  const data = input as Record<string, unknown>;

  // Validate required fields
  if (typeof data.field !== "string") {
    throw new Error("Invalid input: field must be string");
  }

  return data as ValidatedType;
}
```

## Transactional Integrity

For stateful operations:

- **Atomic Operations**: Complete or rollback, no partial states
- **State Tracking**: Maintain history/registry for audit trails
- **Idempotency**: Same input produces same output
- **Recovery**: Clear rollback procedures

See [src/transaction-manager/src/server.ts](mdc:src/transaction-manager/src/server.ts) for transaction patterns.

## Human-in-the-Loop (HITL)

Sensitive operations require human approval:

- Data deletion
- Data export
- Configuration changes
- High-risk decisions

Pattern:

```typescript
if (operation === "delete" && !confirmed) {
  return {
    content: [
      {
        type: "text",
        text: "‚ö†Ô∏è This operation requires confirmation. Please review and confirm deletion.",
      },
    ],
    requiresConfirmation: true,
  };
}
```

## Enterprise Security Patterns

### Least-Privilege Access

- Default deny, explicit allow
- Scope permissions to minimum required
- Validate user context for all operations

### Comprehensive Audit Logging

All MCP operations should log:

- Timestamp
- User/session ID
- Operation type
- Input parameters (sanitized)
- Result status
- Error details (if applicable)

### GDPR Compliance

- Data retention policies
- Right to erasure support
- Data portability (export)
- Consent tracking
- Privacy by design

## Server Shutdown Handling

Graceful shutdown pattern:

```typescript
async function shutdown(exitCode: number = 0): Promise<void> {
  console.error("Shutting down gracefully...");
  // Close connections
  // Flush logs
  // Save state
  process.exit(exitCode);
}

process.on("SIGINT", () => shutdown(0));
process.on("SIGTERM", () => shutdown(0));
```

## Tool Handler Template with Inline Comments

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { CallToolRequestSchema, ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";

/**
 * Main MCP server class following enterprise patterns
 */
class MyMCPServer {
  // State tracking for audit trails
  private history: Record<string, OperationData[]> = {};
  private sessionOrder: string[] = [];
  private readonly maxSessions = Number(process.env.MAX_SESSIONS ?? "100");

  /**
   * Validates tool input with type guards
   * Always validate before processing
   */
  private validateInput(input: unknown): ValidatedType {
    if (typeof input !== "object" || input === null) {
      throw new Error("Invalid input: expected object");
    }

    const data = input as Record<string, unknown>;

    // Validate required fields
    if (typeof data.field !== "string") {
      throw new Error("Invalid input: field must be string");
    }

    return data as ValidatedType;
  }

  /**
   * Main processing method
   * Returns structured Result type
   */
  public processOperation(input: unknown): Result {
    try {
      // 1. Validate input
      const validated = this.validateInput(input);

      // 2. Update state/history for audit trail
      this.updateHistory(validated);

      // 3. Process operation
      const result = this.performOperation(validated);

      // 4. Return success result
      return {
        content: [{ type: "text", text: this.visualize(result) }],
      };
    } catch (error) {
      // 5. Handle errors gracefully
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Error: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
        isError: true,
      };
    }
  }

  private updateHistory(data: ValidatedType): void {
    // Track for GDPR compliance and audit trails
    const sessionId = data.sessionId || "default";

    if (!this.history[sessionId]) {
      this.history[sessionId] = [];
      this.sessionOrder.push(sessionId);
    }

    this.history[sessionId].push(data);

    // Cleanup old sessions (data minimization)
    while (this.sessionOrder.length > this.maxSessions) {
      const oldest = this.sessionOrder.shift()!;
      delete this.history[oldest];
    }
  }

  private performOperation(data: ValidatedType): ProcessedData {
    // Core business logic here
    return { result: "processed" };
  }

  private visualize(data: ProcessedData): string {
    // Human-readable formatting
    return `Operation successful: ${JSON.stringify(data)}`;
  }
}

/**
 * Server initialization with proper error handling
 */
async function runServer() {
  const server = new Server(
    {
      name: "my-mcp-server",
      version: "1.0.0",
    },
    {
      capabilities: {
        tools: {}, // Enable tool support
      },
    }
  );

  const serverInstance = new MyMCPServer();

  // Tool call handler
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    switch (name) {
      case "my_tool":
        return serverInstance.processOperation(args);
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  });

  // List tools handler
  server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: "my_tool",
        description: "Description of what the tool does",
        inputSchema: {
          type: "object",
          properties: {
            field: {
              type: "string",
              description: "Field description",
            },
          },
          required: ["field"],
        },
      },
    ],
  }));

  // Graceful shutdown
  async function shutdown(exitCode: number = 0): Promise<void> {
    console.error("Shutting down gracefully...");
    try {
      if (server && typeof server.close === "function") {
        await server.close();
      }
      console.error("Shutdown completed successfully");
    } catch (error) {
      console.error("Error during shutdown:", error);
      exitCode = 1;
    } finally {
      process.exit(exitCode);
    }
  }

  // Signal handlers
  process.on("SIGINT", () => void shutdown(0));
  process.on("SIGTERM", () => void shutdown(0));
  process.on("uncaughtException", (error) => {
    console.error("Uncaught exception:", error);
    void shutdown(1);
  });
  process.on("unhandledRejection", (reason) => {
    console.error("Unhandled rejection:", reason);
    void shutdown(1);
  });

  // Start server
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

// Execute with error handling
runServer().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
```

## Validation Pattern Examples

### String Validation

```typescript
if (typeof data.field !== "string" || data.field.trim() === "") {
  throw new Error("Invalid field: must be non-empty string");
}
```

### Number Range Validation

```typescript
if (typeof data.confidence !== "number" || data.confidence < 0 || data.confidence > 1) {
  throw new Error("Invalid confidence: must be 0.0-1.0");
}
```

### Enum Validation

```typescript
const allowedTypes = ["option1", "option2", "option3"] as const;
if (!allowedTypes.includes(data.type as any)) {
  throw new Error(`Invalid type: must be one of ${allowedTypes.join(", ")}`);
}
```

### Array Validation

```typescript
if (!Array.isArray(data.items) || data.items.length === 0) {
  throw new Error("Invalid items: must be non-empty array");
}
```

## Reference Implementations

- [src/memory/src/index.ts](mdc:src/memory/src/index.ts) - Knowledge graph with CRUD operations
- [src/decision-framework/src/index.ts](mdc:src/decision-framework/src/index.ts) - Complex state management
- [src/transaction-manager/src/server.ts](mdc:src/transaction-manager/src/server.ts) - Transaction handling

## See Also

- [Velocity Hub](mdc:.cursor/rules/00-velocity-hub.mdc) - Complete workflow guide
- [MCP Servers](mdc:.cursor/rules/21-mcp-servers.mdc) - Detailed implementation patterns
- [Enterprise Standards](mdc:.cursor/rules/02-enterprise-standards.mdc) - Security & GDPR compliance
- [Testing](mdc:.cursor/rules/11-testing.mdc) - Test coverage requirements
- [Workers Deployment](mdc:.cursor/rules/30-workers-deployment.mdc) - Production deployment
