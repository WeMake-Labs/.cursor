---
description: MCP Server Implementation Patterns
alwaysApply: false
---

# MCP Server Implementation Patterns

> **Copy-paste templates for maximum velocity**

## Quick Navigation

- 🚀 [Velocity Hub](mdc:.cursor/rules/00-velocity-hub.mdc) - Start here
- 📚 [MCP Protocol](mdc:.cursor/rules/20-mcp-protocol.mdc) - MCP standards
- 🔧 [Automation Suggestions](mdc:.cursor/rules/04-automation-suggestions.mdc) - Boilerplate generation
- 🧪 [Testing](mdc:.cursor/rules/11-testing.mdc) - Testing patterns
- 📖 [Documentation](mdc:.cursor/rules/12-documentation.mdc) - README templates

## Standard MCP Server Structure

All MCP servers in this monorepo follow a consistent architecture pattern. Reference:
[src/decision-framework/src/index.ts](mdc:src/decision-framework/src/index.ts)

## Server Architecture Decision Tree

```
New MCP Server?
│
├─ Simple stateless operation?
│  └─ Use: Basic validation + single process method
│      Example: [sequential-thinking](mdc:src/sequential-thinking/src/index.ts)
│
├─ Stateful with history tracking?
│  └─ Use: History registry + session management
│      Example: [memory](mdc:src/memory/src/index.ts)
│
├─ Multi-stage workflow?
│  └─ Use: Stage tracking + iterative operations
│      Example: [decision-framework](mdc:src/decision-framework/src/index.ts)
│
├─ Multi-persona simulation?
│  └─ Use: Persona registry + dialogue tracking
│      Example: [collaborative-reasoning](mdc:src/collaborative-reasoning/src/index.ts)
│
└─ Transaction management?
   └─ Use: Transaction state + rollback support
       Example: [transaction-manager](mdc:src/transaction-manager/src/server.ts)
```

## Required Components

### 1. Validation Functions

Every server MUST implement input validation for all tool parameters:

```typescript
private validateInput(input: unknown): ValidatedDataType {
  if (typeof input !== "object" || input === null) {
    throw new Error("Invalid input: expected object");
  }

  const data = input as Record<string, unknown>;

  // Validate required fields with type guards
  if (typeof data.field !== "string") {
    throw new Error("Invalid input: field must be string");
  }

  // Validate enums
  if (!["option1", "option2"].includes(data.type as string)) {
    throw new Error(`Invalid type: ${data.type}`);
  }

  // Validate ranges
  if (typeof data.confidence !== "number" ||
      data.confidence < 0 || data.confidence > 1) {
    throw new Error("Invalid confidence: must be 0.0-1.0");
  }

  return data as ValidatedDataType;
}
```

### 2. Process Methods

Process methods return structured Result types:

```typescript
type Result = {
  content: Array<{ type: "text"; text: string }>;
  isError?: boolean;
};

public processOperation(input: unknown): Result {
  try {
    // 1. Validate input
    const validated = this.validateInput(input);

    // 2. Update state/registries
    this.updateRegistries(validated);

    // 3. Process operation
    const result = this.performOperation(validated);

    // 4. Generate visualization
    const visualization = this.visualize(validated);

    // 5. Return success result
    return {
      content: [{ type: "text", text: visualization }],
    };
  } catch (error) {
    // 6. Handle errors gracefully
    return {
      content: [{
        type: "text",
        text: `❌ Error: ${error instanceof Error ? error.message : String(error)}`
      }],
      isError: true,
    };
  }
}
```

### 3. History and Registry Tracking

Maintain state for audit trails and session continuity:

```typescript
class MyMCPServer {
  // History tracking
  private operationHistory: Record<string, OperationData[]> = {};

  // Registry tracking
  private entityRegistry: Record<string, Record<string, Entity>> = {};
  private relationRegistry: Record<string, Relation[]> = {};

  // Session management
  private sessionOrder: string[] = [];
  private readonly maxSessions = Number(process.env.MAX_SESSIONS ?? "100");

  private updateHistory(sessionId: string, data: OperationData): void {
    if (!this.operationHistory[sessionId]) {
      this.operationHistory[sessionId] = [];
      this.sessionOrder.push(sessionId);
    }

    this.operationHistory[sessionId].push(data);

    // Cleanup old sessions (GDPR compliance)
    while (this.sessionOrder.length > this.maxSessions) {
      const oldestSession = this.sessionOrder.shift()!;
      delete this.operationHistory[oldestSession];
    }
  }
}
```

### 4. Visualization Methods

Provide rich CLI output for human readability:

```typescript
private visualize(data: OperationData): string {
  const lines: string[] = [];

  lines.push("\n┌─────────────────────────────────────┐");
  lines.push("│  Operation Result                   │");
  lines.push("└─────────────────────────────────────┘\n");

  // Use colors for better readability
  lines.push(`Status: ${this.colorStatus(data.status)}`);
  lines.push(`Confidence: ${this.confidenceBar(data.confidence)}`);

  // Render data structures
  if (data.elements) {
    lines.push("\nElements:");
    for (const element of data.elements) {
      lines.push(`  • ${element.name} (${element.type})`);
    }
  }

  return lines.join("\n");
}

private colorStatus(status: string): string {
  const colors = {
    success: "\x1b[32m", // green
    pending: "\x1b[33m", // yellow
    error: "\x1b[31m",   // red
  };
  const reset = "\x1b[0m";
  const color = colors[status] || "";
  return `${color}${status}${reset}`;
}

private confidenceBar(confidence: number): string {
  const width = 20;
  const filled = Math.round(confidence * width);
  const bar = "█".repeat(filled) + "░".repeat(width - filled);
  return `${bar} ${(confidence * 100).toFixed(0)}%`;
}
```

### 5. Server Initialization

Standard server setup with proper shutdown:

```typescript
async function runServer() {
  const server = new Server(
    {
      name: "my-mcp-server",
      version: "1.0.0",
    },
    {
      capabilities: {
        tools: {},
      },
    }
  );

  const serverInstance = new MyMCPServer();

  // Tool handler
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    switch (name) {
      case "myTool":
        return serverInstance.processOperation(args);
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  });

  // List tools handler
  server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: "myTool",
        description: "Description of what the tool does",
        inputSchema: {
          type: "object",
          properties: {
            field: { type: "string", description: "Field description" },
          },
          required: ["field"],
        },
      },
    ],
  }));

  // Shutdown handlers
  async function shutdown(exitCode: number = 0): Promise<void> {
    console.error("Shutting down gracefully...");

    try {
      // Close server connections
      if (server && typeof server.close === "function") {
        await server.close();
      }

      // Flush any pending database operations
      // Flush any pending logs
      // Close any open streams or connections

      console.error("Shutdown completed successfully");
    } catch (error) {
      console.error("Error during shutdown:", error);
      exitCode = 1;
    } finally {
      process.exit(exitCode);
    }
  }

  // Important: Don't use arrow functions for signal handlers
  process.on("SIGINT", () => {
    void shutdown(0);
  });

  process.on("SIGTERM", () => {
    void shutdown(0);
  });

  // Also handle uncaught errors
  process.on("uncaughtException", (error) => {
    console.error("Uncaught exception:", error);
    void shutdown(1);
  });

  process.on("unhandledRejection", (reason) => {
    console.error("Unhandled rejection:", reason);
    void shutdown(1);
  });

  // Start server
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

runServer().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
```

## Server Class Pattern

```typescript
class MyMCPServer {
  // 1. State tracking
  private history: Record<string, DataType[]> = {};
  private registry: Record<string, Entity> = {};
  private nextId = 1;

  // 2. Validation method
  private validateInput(input: unknown): ValidatedType {
    // Validation logic
  }

  // 3. Update methods
  private updateHistory(data: ValidatedType): void {}
  private updateRegistry(data: ValidatedType): void {}

  // 4. Visualization methods
  private visualize(data: ValidatedType): string {}

  // 5. Public process method
  public processOperation(input: unknown): Result {
    // Main processing logic
  }
}
```

## When to Use Each Pattern

| Pattern              | Use When                              | Key Features                         | Example                 |
| -------------------- | ------------------------------------- | ------------------------------------ | ----------------------- |
| **Basic Validation** | Simple, stateless operations          | Input validation, single output      | Sequential Thinking     |
| **History Tracking** | Need audit trails, session continuity | Session management, GDPR cleanup     | Memory                  |
| **Multi-Stage**      | Complex workflows with stages         | Stage tracking, iteration support    | Decision Framework      |
| **Multi-Persona**    | Simulating multiple viewpoints        | Persona registry, dialogue tracking  | Collaborative Reasoning |
| **Transaction**      | Need atomic operations with rollback  | State snapshots, rollback capability | Transaction Manager     |

### Quick Pattern Selection

**Ask yourself:**

1. Does it need to remember previous operations? → Use History Tracking
2. Does it have multiple stages or iterations? → Use Multi-Stage
3. Does it simulate multiple agents/personas? → Use Multi-Persona
4. Must operations be atomic with rollback? → Use Transaction
5. Otherwise → Use Basic Validation

## Copy-Paste Templates

### Template 1: Basic Server (Stateless)

```typescript
class BasicServer {
  private validateInput(input: unknown): ValidatedType {
    if (typeof input !== "object" || input === null) {
      throw new Error("Invalid input");
    }
    return input as ValidatedType;
  }

  public processOperation(input: unknown): Result {
    try {
      const validated = this.validateInput(input);
      const result = this.process(validated);
      return { content: [{ type: "text", text: result }] };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error.message}` }],
        isError: true,
      };
    }
  }
}
```

### Template 2: History Tracking Server

```typescript
class HistoryServer {
  private history: Record<string, Data[]> = {};
  private sessionOrder: string[] = [];
  private readonly maxSessions = 100;

  private updateHistory(sessionId: string, data: Data): void {
    if (!this.history[sessionId]) {
      this.history[sessionId] = [];
      this.sessionOrder.push(sessionId);
    }
    this.history[sessionId].push(data);

    // GDPR: Cleanup old sessions
    while (this.sessionOrder.length > this.maxSessions) {
      const oldest = this.sessionOrder.shift()!;
      delete this.history[oldest];
    }
  }
}
```

### Template 3: Multi-Stage Server

```typescript
class MultiStageServer {
  private stages: Record<string, { stage: string; iteration: number }> = {};

  private updateStage(id: string, stage: string, iteration: number): void {
    this.stages[id] = { stage, iteration };
  }

  private getNextStage(current: string): string {
    const stageFlow = ["stage1", "stage2", "stage3"];
    const idx = stageFlow.indexOf(current);
    return stageFlow[idx + 1] || current;
  }
}
```

**For complete implementations:** See Reference Implementations below

## Reference Implementations

Study these for patterns:

- [src/decision-framework/src/index.ts](mdc:src/decision-framework/src/index.ts) - Complex multi-stage analysis
- [src/memory/src/index.ts](mdc:src/memory/src/index.ts) - CRUD operations with persistence
- [src/sequential-thinking/src/index.ts](mdc:src/sequential-thinking/src/index.ts) - Simple state tracking
- [src/collaborative-reasoning/src/index.ts](mdc:src/collaborative-reasoning/src/index.ts) - Multi-persona management
- [src/transaction-manager/src/server.ts](mdc:src/transaction-manager/src/server.ts) - Transaction handling

## See Also

- [Velocity Hub](mdc:.cursor/rules/00-velocity-hub.mdc) - Complete workflow guide
- [MCP Protocol](mdc:.cursor/rules/20-mcp-protocol.mdc) - MCP standards and tool handlers
- [Automation Suggestions](mdc:.cursor/rules/04-automation-suggestions.mdc) - AI-generated boilerplate
- [Testing](mdc:.cursor/rules/11-testing.mdc) - Test patterns for servers
- [Documentation](mdc:.cursor/rules/12-documentation.mdc) - Server README templates
